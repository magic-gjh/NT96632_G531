//This source code is generated by UI Designer Studio.
#include <stdio.h>
#include <string.h>
#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "UIGraphics.h"
#include "NVTToolCommand.h"
#include "UIFlowWndPhotoRes.c"
#include "UIFlowWndPhoto.h"
#include "UIFlowPhotoFuncs.h"
#include "UIFlowWndWrnMsg.h"
#include "UIMenuWndPhotoStill.h"
//#include "UIMenuWndPhotoQuickSetting.h"
#include "UIPhotoObj.h"
#include "UISystemObj.h"
#include "UIFlowWndCommonAPI.h"
#include "VoltageDet.h"
#include "IDE.h"
#include "ime_lib.h"
#include "GlobalVar.h"
#include "KeyScanTsk.h"
#include "PlaySoundTsk.h"
#include "PhotoTsk.h"
#include "PhotoDisplayTsk.h"
#include "FileSysTsk.h"
#include "PrimaryTsk.h"
#include "Alg_IPLMode.h"
#include "UIMenuMovieSettings.h"



//-----------------------------------------------------------------------------
// UIFlowWndPhoto User Variable & Function Declarations
//-----------------------------------------------------------------------------
static BOOL g_bInitCfgSetting       = FALSE;

static UINT32 g_uiMaskKeyPress      = PHOTO_KEY_PRESS_MASK;
static UINT32 g_uiMaskKeyRelease    = PHOTO_KEY_RELEASE_MASK;
static UINT32 g_uiMaskKeyContinue   = PHOTO_KEY_CONTINUE_MASK;
static UINT32 g_uiChildWndMode      = PHOTO_CHILD_WND_NULL;

static BOOL g_bZoomInPressed        = FALSE;
static BOOL g_bZoomOutPressed       = FALSE;

static UINT32 g_uiSelfTimerID       = NULL_TIMER;
static UINT32 g_uiQviewTimerID      = NULL_TIMER;

static UINT32 g_uiSelfTimerCnt      = 0;
static BOOL g_bSelfTimerStart       = FALSE;
static BOOL g_bQviewTimerStart      = FALSE;
static BOOL g_bStartCapture         = FALSE;
static BOOL g_bDoingContShot        = FALSE;
static BOOL g_bContShotCfgSetOn     = FALSE;
static BOOL g_bSceneModeCfgSetOther = FALSE;

static UINT32 g_uiFreePicNum        = 0;
extern UINT32 uiImageRotatePreValue ;

extern BOOL ACC5MinMode;

static void UIFlowWndPhoto_InitCfgSetting(void);
static void UIFlowWndPhoto_InitWndParam(void);
static void UIFlowWndPhoto_UpdateWndInfo(void);
static void UIFlowWndPhoto_SetToQuickView(AlgMsgInfo *);
static void UIFlowWndPhoto_SetToPreview(void);
static void UIFlowWndPhoto_SetFdSdProc(UINT32);
static void UIFlowWndPhoto_ForceLockFdSd(UINT32);
static void UIFlowWndPhoto_SetCaptureModeSpecial(UINT32);
static void UIFlowWndPhoto_SetSceneModeSpecial(UINT32);

#define TIMER_ONE_SEC               1000
#define TIMER_TWO_SEC               2000
#define RAPID_LED_TIME              200
#define SELFTIMER_LED_TIME          500

#define FD_FRAME_RATE               10   //(10frame/30fps) = 333ms = update time
#define FD_OSDFRAME_LEN             8

//-----------------------------------------------------------------------------
// UIFlowWndPhoto ToolGen
//-----------------------------------------------------------------------------
//---------------------UIFlowWndPhotoCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndPhoto)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticICN_DSCMode)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_CaptureMode)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticTXT_SelftimerCnt)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_ISO)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticTXT_FreePic)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_EV)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticTXT_Size)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_WB)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Quality)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Color)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_FD)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Scene)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Macro)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Storage)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_LedLight)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticTXT_DZoom)
CTRL_LIST_ITEM(UIFlowWndPhoto_StatusICN_Battery)
CTRL_LIST_ITEM(UIFlowWndPhoto_PNL_FDFrame)
CTRL_LIST_ITEM(UIFlowWndPhoto_StaticICN_AntiShake)
CTRL_LIST_END

//----------------------UIFlowWndPhotoCtrl Event---------------------------
INT32 UIFlowWndPhoto_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyUp(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyDown(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyLeft(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyRight(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyEnter(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyShutter2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyZoomin(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyZoomout(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyMenu(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyMode(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnKeyPlayback(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnStorageInit(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnStorageChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnMacroChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnFlashCharging(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnBattery(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnJpgOK(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnCaptureEnd(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnCapFstOK(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnSmartScene(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnOZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnDZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnFdEnd(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnSdEnd(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPhoto_OnOSDReflash(VControl *, UINT32, UINT32 *);

EVENT_BEGIN(UIFlowWndPhoto)
EVENT_ITEM(NVTEVT_OPEN_WINDOW,UIFlowWndPhoto_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW,UIFlowWndPhoto_OnClose)
EVENT_ITEM(NVTEVT_KEY_UP,UIFlowWndPhoto_OnKeyUp)
EVENT_ITEM(NVTEVT_KEY_DOWN,UIFlowWndPhoto_OnKeyDown)
EVENT_ITEM(NVTEVT_KEY_LEFT,UIFlowWndPhoto_OnKeyLeft)
EVENT_ITEM(NVTEVT_KEY_RIGHT,UIFlowWndPhoto_OnKeyRight)
EVENT_ITEM(NVTEVT_KEY_ENTER,UIFlowWndPhoto_OnKeyEnter)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2,UIFlowWndPhoto_OnKeyShutter2)
EVENT_ITEM(NVTEVT_KEY_ZOOMIN,UIFlowWndPhoto_OnKeyZoomin)
EVENT_ITEM(NVTEVT_KEY_ZOOMOUT,UIFlowWndPhoto_OnKeyZoomout)
EVENT_ITEM(NVTEVT_KEY_MENU,UIFlowWndPhoto_OnKeyMenu)
EVENT_ITEM(NVTEVT_KEY_MODE,UIFlowWndPhoto_OnKeyMode)
EVENT_ITEM(NVTEVT_KEY_PLAYBACK,UIFlowWndPhoto_OnKeyPlayback)
EVENT_ITEM(NVTEVT_CHILD_CLOSE,UIFlowWndPhoto_OnChildClose)
EVENT_ITEM(NVTEVT_STORAGE_INIT,UIFlowWndPhoto_OnStorageInit)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE,UIFlowWndPhoto_OnStorageChange)
EVENT_ITEM(NVTEVT_MACRO_CHANGE,UIFlowWndPhoto_OnMacroChange)
EVENT_ITEM(NVTEVT_FLASHCHARGING,UIFlowWndPhoto_OnFlashCharging)
EVENT_ITEM(NVTEVT_BATTERY,UIFlowWndPhoto_OnBattery)
EVENT_ITEM(NVTEVT_TIMER,UIFlowWndPhoto_OnTimer)
EVENT_ITEM(NVTEVT_CB_JPGOK,UIFlowWndPhoto_OnJpgOK)
EVENT_ITEM(NVTEVT_CB_CAPTUREEND,UIFlowWndPhoto_OnCaptureEnd)
EVENT_ITEM(NVTEVT_CB_CAPFSTOK,UIFlowWndPhoto_OnCapFstOK)
EVENT_ITEM(NVTEVT_CB_SMARTSCENE,UIFlowWndPhoto_OnSmartScene)
EVENT_ITEM(NVTEVT_CB_OZOOMSTEPCHG,UIFlowWndPhoto_OnOZoomStepChange)
EVENT_ITEM(NVTEVT_CB_DZOOMSTEPCHG,UIFlowWndPhoto_OnDZoomStepChange)
EVENT_ITEM(NVTEVT_CB_FDEND,UIFlowWndPhoto_OnFdEnd)
EVENT_ITEM(NVTEVT_CB_SDEND,UIFlowWndPhoto_OnSdEnd)
EVENT_ITEM(NVTEVT_OSD_REFLASH,UIFlowWndPhoto_OnOSDReflash)

EVENT_END

INT32 UIFlowWndPhoto_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    debug_ind(("UIFlowWndPhoto: OnOpen\r\n"));

	if(ACC5MinMode==TRUE){
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, FLGKEY_KEY_MASK_NULL);
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, FLGKEY_KEY_MASK_NULL);	
	}
        else{		
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_DEFAULT);
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, FLGKEY_KEY_REL_MASK_DEFAULT);
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, FLGKEY_KEY_CONT_MASK_DEFAULT);
    	  }
    /* Init photo config settings */
    UIFlowWndPhoto_InitCfgSetting();

    /* Init window parameters */
    UIFlowWndPhoto_InitWndParam();

    /* Set file id */
    DCF_SetFileId();
    FilesysWaitInitFinish(FST_TIME_INFINITE);

    /* Update window info */
    UIFlowWndPhoto_UpdateWndInfo();
    KeyScan_SetDetGSPNAVIEn(TRUE);

    Ux_DefaultEvent(pCtrl,NVTEVT_OPEN_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    debug_ind(("UIFlowWndPhoto: OnClose\r\n"));

    /* Stop selftimer if exists */
    if(g_uiSelfTimerID != NULL_TIMER)
    {
        KeyScan_stopTimer(&g_uiSelfTimerID);
        g_bSelfTimerStart = FALSE;
    }
    KeyScan_TurnOffLED(KEYSCAN_LED_FCS);

    /* Stop QuickView timer if exists */
    if(g_uiQviewTimerID != NULL_TIMER)
    {
        KeyScan_stopTimer(&g_uiQviewTimerID);
        g_bQviewTimerStart = FALSE;
        UIFlowWndPhoto_SetToPreview();
    }

    /* Reset key press/release/continue mask to default */
    Ux_FlushEvent();
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_DEFAULT);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, FLGKEY_KEY_REL_MASK_DEFAULT);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, FLGKEY_KEY_CONT_MASK_DEFAULT);

    Ux_DefaultEvent(pCtrl,NVTEVT_CLOSE_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyUp(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    //return UIFlowWndPhoto_OnKeyZoomin(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndPhoto_OnKeyDown(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    //return UIFlowWndPhoto_OnKeyZoomout(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndPhoto_OnKeyLeft(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyRight(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    /* Force to lock FD/SD functions before opening Menu */
    //UIFlowWndPhoto_ForceLockFdSd(Get_FDIndex());

    //g_uiChildWndMode = PHOTO_CHILD_WND_QUICKSETTING;
    //Ux_OpenWindow(&UIMenuWndPhotoQuickSettingCtrl,0);

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyEnter(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndPhoto_OnKeyShutter2(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndPhoto_OnKeyShutter2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiEvtKeyAct = 0;

    if(paramNum > 0)
        uiEvtKeyAct = paramArray[0];
	
    if (GPIOMap_DetStrgCard() == FALSE)
    {
        g_uiChildWndMode = PHOTO_CHILD_WND_WRNMSG;
        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,FLOWWRNMSG_ISSUE_NO_CARD,FLOWWRNMSG_TIMER_2SEC);
        return NVTEVT_CONSUME;		
    }
	
    switch(uiEvtKeyAct)
    {
        case NVTEVT_KEY_PRESS:
        {
            /* Check if in quick review process */
            if(Get_QuickReviewIndex() != QREVIEW_0SEC)
            {
                if(g_uiQviewTimerID != NULL_TIMER)
                {
                    KeyScan_stopTimer(&g_uiQviewTimerID);
                    g_bQviewTimerStart = FALSE;

                    /* Set to preview mode */
                    UIFlowWndPhoto_SetToPreview();

                    /* Resume key after quick view completed */
                    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
                    Ux_FlushEvent();

                    /* Update window info */
                    UIFlowWndPhoto_UpdateWndInfo();
                    return NVTEVT_CONSUME;
                }
            }

            /* Check capture prerequisite */
            if(UI_Validate_Storage(STORAGE_CHECK_FULL, &g_uiFreePicNum) == FALSE)
            {
                debug_err(("UIFlowWndPhoto_OnKeyShutter2: Card or memory full!\r\n"));
                return NVTEVT_CONSUME;
            }
            if(GetBatteryLevel() == VOLDET_BATTERY_LVL_EMPTY)
            {
                debug_err(("UIFlowWndPhoto_OnKeyShutter2: Battery is too low!\r\n"));
                return NVTEVT_CONSUME;
            }
            #if (_FLASHLIGHT_ != _FLASHLIGHT_NONE_)
            if(KeyScan_IsFlashCharging())
            {
                debug_err(("UIFlowWndPhoto_OnKeyShutter2: Flash is charging!\r\n"));
                return NVTEVT_CONSUME;
            }
            #endif

            /* Check selftimer setting */
            if(Get_SelftimerIndex() != SELFTIMER_OFF)   //Selftimer case
            {
                if(g_bSelfTimerStart != TRUE)   //Selftimer to be started case
                {
                    /* Start selftimer */
                    g_uiSelfTimerID = KeyScan_startTimer(TIMER_ONE_SEC, NVTEVT_SELFTIMER, CONTINUE);
                    g_bSelfTimerStart = TRUE;

                    /* Suspend all keys, except capture key while selftimer started */
                    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, PHOTO_CAPTURE_KEY);

                    if(Get_SelftimerIndex() == SELFTIMER_ON_2S)
                    {
                        g_uiSelfTimerCnt = 2;
                        KeyScan_TurnOnLED(KEYSCAN_LED_FCS);
                        KeyScan_startTimer(RAPID_LED_TIME, NVTEVT_SELFTIMER_RAPID_LED, ONE_SHOT);
                    }
                    else if(Get_SelftimerIndex() == SELFTIMER_ON_5S)
                    {
                        g_uiSelfTimerCnt = 5;
                    }
                    else   //SELFTIMER_ON_10S
                    {
                        g_uiSelfTimerCnt = 10;
                    }

                    /* Draw selftimer counter */
                    UxCtrl_SetShow(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl,TRUE);
                    UxStatic_SetData(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl,STATIC_VALUE,Txt_Pointer(Get_SelftimerCntString(g_uiSelfTimerCnt)));
                }
                else   //Selftimer already started case (make it stopped)
                {
                    /* Stop selftimer */
                    if(g_uiSelfTimerID != NULL_TIMER)
                    {
                        KeyScan_stopTimer(&g_uiSelfTimerID);
                        g_bSelfTimerStart = FALSE;
                    }

                    KeyScan_TurnOffLED(KEYSCAN_LED_FCS);
                    g_uiSelfTimerCnt = 0;
                    UxCtrl_SetShow(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl,FALSE);

                    /* Resume key */
                    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
                    Ux_FlushEvent();
                }
            }
            else   //Normal case
            {
                /* Suspend all keys before sending capture command */
                KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
                Ux_FlushEvent();

                /* Clear the whole OSD screen */
                UxCtrl_SetAllChildShow(pCtrl,FALSE);

                /* Start to send capture command */
                g_bStartCapture = TRUE;
                Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_CAPTURE,0);
            }
            break;
        }

        case NVTEVT_KEY_RELEASE:
        {
            //Rsvd
            break;
        }

        default:
            debug_err(("UIFlowWndPhoto_OnKeyShutter2: Unknown evt 0x%x\r\n", uiEvtKeyAct));
            break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyZoomin(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiEvtKeyAct = 0;

    if(paramNum > 0)
        uiEvtKeyAct = paramArray[0];

    switch(uiEvtKeyAct)
    {
        case NVTEVT_KEY_PRESS:
        {
            /* Set it to true for key released event verification */
            g_bZoomInPressed = TRUE;

            /*
             * Suspend all keys while keep ZoomIn pressed.
             * Gotta resume them after ZoomIn key released.
             */
            KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);

            /* Send zoom in evt to obj for handling */
            Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_ZOOMIN,0);
            break;
        }

        case NVTEVT_KEY_RELEASE:
        {
            if(g_bZoomInPressed)
            {
                /* Send zoom stop evt to obj for handling */
                Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_ZOOMSTOP,0);

                /* Update FD/SD function process (lock/unlock) */
                UIFlowWndPhoto_SetFdSdProc(Get_FDIndex());

                /* Resume keys after ZoomIn released */
                KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);

                g_bZoomInPressed = FALSE;
            }
            break;
        }

        default:
            debug_err(("UIFlowWndPhoto_OnKeyZoomin: Unknown evt 0x%x\r\n", uiEvtKeyAct));
            break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyZoomout(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiEvtKeyAct = 0;

    if(paramNum > 0)
        uiEvtKeyAct = paramArray[0];

    switch(uiEvtKeyAct)
    {
        case NVTEVT_KEY_PRESS:
        {
            /* Set it to true for key released event verification */
            g_bZoomOutPressed = TRUE;

            /*
             * Suspend all keys while keep ZoomOut pressed.
             * Gotta resume them after ZoomOut key released.
             */
            KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);

            /* Send zoom in evt to obj for handling */
            Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_ZOOMOUT,0);
            break;
        }

        case NVTEVT_KEY_RELEASE:
        {
            if(g_bZoomOutPressed)
            {
                /* Send zoom stop evt to obj for handling */
                Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_ZOOMSTOP,0);

                /* Update FD/SD function process (lock/unlock) */
                UIFlowWndPhoto_SetFdSdProc(Get_FDIndex());

                /* Resume keys after ZoomOut released */
                KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);

                g_bZoomOutPressed = FALSE;
            }
            break;
        }

        default:
            debug_err(("UIFlowWndPhoto_OnKeyZoomout: Unknown evt 0x%x\r\n", uiEvtKeyAct));
            break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyMenu(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    /* Force to lock FD/SD functions before opening Menu */
    UIFlowWndPhoto_ForceLockFdSd(Get_FDIndex());

    g_uiChildWndMode = PHOTO_CHILD_WND_MENU;
    Ux_OpenWindow(&UIMenuWndPhotoStillCtrl,0);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_SendEvent(&UISystemObjCtrl,NVTEVT_CHANGE_DSCMODE,1,DSCMODE_CHGTO_NEXT);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnKeyPlayback(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_SendEvent(&UISystemObjCtrl,NVTEVT_FORCETO_PLAYBACK_MODE,0);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiWnd = g_uiChildWndMode;
    IPL_OBJ obj;

    /* Set key mask to self-original state */
    Ux_FlushEvent();
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, g_uiMaskKeyRelease);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, g_uiMaskKeyContinue);

    /* Reset child window record */
    g_uiChildWndMode = PHOTO_CHILD_WND_NULL;

    switch(uiWnd)
    {
        case PHOTO_CHILD_WND_WRNMSG:
            if(paramNum > 0)
            {
                if(paramArray[0] == NVTRET_ENTER_MENU)
                {
                    /* Force to lock FD/SD functions before opening Menu */
                    UIFlowWndPhoto_ForceLockFdSd(Get_FDIndex());

                    /* Create Menu window */
                    g_uiChildWndMode = PHOTO_CHILD_WND_MENU;
                    Ux_OpenWindow(&UIMenuWndPhotoStillCtrl,0);
                    return NVTEVT_CONSUME;
                }
            }
            break;

        case PHOTO_CHILD_WND_MENU:
        case PHOTO_CHILD_WND_QUICKSETTING:
        default:
#if 0			
	if(uiImageRotatePreValue != Get_ImageRotateIndex())
	{
	   uiImageRotatePreValue = Get_ImageRotateIndex();
	   
	   obj.uiCmd = IPL_CMD_CHG_MODE;
	   obj.Mode = IPL_MODE_OFF;
	   IPL_SetCmd(&obj);
	    if(Get_ImageRotateIndex() == IMAGE_ROTATE_OFF)
	    {
			UI_SetParameter(_ImageFlip,_Flip_Off);
	    }
	    else
	    {
			UI_SetParameter(_ImageFlip,_Flip_H_V);
	    }
	   obj.uiCmd = IPL_CMD_CHG_MODE;
	   obj.Mode = IPL_MODE_PREVIEW;
	   IPL_SetCmd(&obj);	
	}			
#endif	
            /* Update window info */
            UIFlowWndPhoto_UpdateWndInfo();
            break;
    }

    Ux_DefaultEvent(pCtrl,NVTEVT_CHILD_CLOSE,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnStorageInit(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    BOOL bCurrCardRemoved = (GetCardStatus() == CARD_REMOVED)? TRUE : FALSE;

    debug_err(("UIFlowWndPhoto: OnStorageInit - %s\r\n", (bCurrCardRemoved)? "MEM" : "Card"));
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnMacroChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    debug_err(("UIFlowWndPhoto: OnMacroChange - %s\r\n", (Get_MacroIndex() == MACRO_ON)? "ON" : "OFF"));

    if((!g_bStartCapture) && (!g_bQviewTimerStart))
    {
        /* Update window info */
        UIFlowWndPhoto_UpdateWndInfo();
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnFlashCharging(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (_FLASHLIGHT_ != _FLASHLIGHT_NONE_)
    NVTEVT event;

    event = paramArray[0];
    debug_ind(("UIFlowWndPhoto OnFlashCharging event = 0x%x\r\n", event));

    if((!g_bStartCapture) && (!g_bQviewTimerStart))
    {
        switch(event)
        {
            case NVTEVT_FLASHCHARGING_PROC:
                if(UxCtrl_IsShow(&UIFlowWndPhoto_StatusICN_FlashCtrl))
                {
                    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_FlashCtrl,FALSE);
                }
                else
                {
                    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_FlashCtrl,TRUE);
                }
                break;

            case NVTEVT_FLASHCHARGING_END:
                UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_FlashCtrl,TRUE);
                break;

            default:
                break;
        }
    }
#endif
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnBattery(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    if((!g_bStartCapture) && (!g_bQviewTimerStart))
    {
        /* Update window info */
        //UIFlowWndPhoto_UpdateWndInfo();
        UxState_SetData(&UIFlowWndPhoto_StatusICN_BatteryCtrl,STATE_CURITEM,GetBatteryLevel());        
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    NVTEVT event;
    static BOOL bRapidLEDOn = FALSE;

    event = paramArray[0];
    debug_ind(("UIFlowWndPhoto OnTimer event = 0x%x\r\n", event));

    switch(event)
    {
        case NVTEVT_SELFTIMER:
        {
            /**************************************************************************************
            **
            ** Selftimer Timeout Action
            **
            **************************************************************************************/
            debug_ind(("UIFlowWndPhoto g_uiSelfTimerCnt = %ld\r\n", g_uiSelfTimerCnt));
            if(g_uiSelfTimerCnt == 1)
            {
                if(g_uiSelfTimerID != NULL_TIMER)
                {
                    KeyScan_stopTimer(&g_uiSelfTimerID);
                    g_bSelfTimerStart = FALSE;
                }

                KeyScan_TurnOffLED(KEYSCAN_LED_FCS);
                g_uiSelfTimerCnt = 0;
                UxCtrl_SetShow(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl,FALSE);

                /* Suspend all keys before sending capture command */
                KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
                Ux_FlushEvent();

                /* Clear the whole OSD screen */
                UxCtrl_SetAllChildShow(pCtrl,FALSE);

                /* Start to send capture command */
                g_bStartCapture = TRUE;
                Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_CAPTURE,0);
            }
            else
            {
                g_uiSelfTimerCnt --;
                UxStatic_SetData(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl,STATIC_VALUE,Txt_Pointer(Get_SelftimerCntString(g_uiSelfTimerCnt)));

                if(g_uiSelfTimerCnt > 2)
                {
                    KeyScan_TurnOnLED(KEYSCAN_LED_FCS);
                    KeyScan_startTimer(SELFTIMER_LED_TIME, NVTEVT_SELFTIMER_LED, ONE_SHOT);
                }
                else if(g_uiSelfTimerCnt == 2)
                {
                    KeyScan_TurnOnLED(KEYSCAN_LED_FCS);
                    bRapidLEDOn = TRUE;
                    KeyScan_startTimer(RAPID_LED_TIME, NVTEVT_SELFTIMER_RAPID_LED, ONE_SHOT);
                }
            }
            break;
        }

        case NVTEVT_QUICKVIEWTIMER:
        {
            /**************************************************************************************
            **
            ** QuickView Timeout Action
            **
            **************************************************************************************/
            if(g_uiQviewTimerID != NULL_TIMER)
            {
                KeyScan_stopTimer(&g_uiQviewTimerID);
                g_bQviewTimerStart = FALSE;
            }

            /* Set to preview mode */
            UIFlowWndPhoto_SetToPreview();

            /* Resume key after quick view completed */
            KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
            Ux_FlushEvent();

            /* Update window info */
            UIFlowWndPhoto_UpdateWndInfo();
            break;
        }

        case NVTEVT_SELFTIMER_LED:
        {
            /**************************************************************************************
            **
            ** Selftimer LED Timeout Action
            **
            **************************************************************************************/
            KeyScan_TurnOffLED(KEYSCAN_LED_FCS);
            break;
        }

        case NVTEVT_SELFTIMER_RAPID_LED:
        {
            /**************************************************************************************
            **
            ** Selftimer Rapid LED Timeout Action
            **
            **************************************************************************************/
            if(g_bSelfTimerStart)
            {
                if(bRapidLEDOn)
                {
                    KeyScan_PlaySound(PLAYSOUND_SOUND_KEY_OTHERS);
                    KeyScan_TurnOnLED(KEYSCAN_LED_FCS);
                    bRapidLEDOn = FALSE;
                    KeyScan_startTimer(RAPID_LED_TIME, NVTEVT_SELFTIMER_RAPID_LED, ONE_SHOT);
                }
                else
                {
                    KeyScan_TurnOffLED(KEYSCAN_LED_FCS);
                    bRapidLEDOn = TRUE;
                    KeyScan_startTimer(RAPID_LED_TIME, NVTEVT_SELFTIMER_RAPID_LED, ONE_SHOT);
                }
            }
            break;
        }

        default:
            break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnJpgOK(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    AlgMsgInfo *pAlgMsgInfo = Get_AlgMsgInfo();
    UINT32 uiQVTimeVal = TIMER_ONE_SEC * (Get_QuickReviewValue(Get_QuickReviewIndex()));

    debug_err(("UIFlowWndPhoto: OnJpgOK\r\n"));

    g_bStartCapture = FALSE;

    #if (_FLASHLIGHT_ != _FLASHLIGHT_NONE_)
    /* Enable flash charging */
    if(Get_FlashIndex() != FLASH_OFF)
    {
        KeyScan_EnableFlashCharging(TRUE);
    }
    #endif

    /* Check capture mode & quick review state */
    if((Get_ContShotIndex() == CONT_SHOT_OFF) && (Get_QuickReviewIndex() != QREVIEW_0SEC))
    {   /* Cont shot: off & quick review: on, process QuickView with timer */

        /* Set to quick review mode */
        UIFlowWndPhoto_SetToQuickView(pAlgMsgInfo);

        g_uiQviewTimerID = KeyScan_startTimer(uiQVTimeVal, NVTEVT_QUICKVIEWTIMER, ONE_SHOT);
        g_bQviewTimerStart = TRUE;

        /* Resume only capture key while quick view timer started */
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, PHOTO_CAPTURE_KEY);

        /* Clear the whole OSD screen */
        //UxCtrl_SetAllChildShow(pCtrl,FALSE);

        /* Than set only essential areas shown when DSC is processing QuickView */
        //Rsvd
    }
    else if(Get_ContShotIndex() != CONT_SHOT_OFF)
    {   /* Cont shot: on, process IQ internal QuickView till cont shot completed */

        if(!g_bDoingContShot)
        {
            /* Set to cont shot internal QuickView */
            UIFlowWndPhoto_SetToQuickView(pAlgMsgInfo);

            /* Suspend all keys while processing cont shot internal QuickView */
            //KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, 0);

            g_bDoingContShot = TRUE;

            /* Clear the whole OSD screen */
            UxCtrl_SetAllChildShow(pCtrl,FALSE);

            /* Than set only essential areas shown when DSC is processing QuickView */
            //Rsvd
        }

        /*
         * Just update current free picture number and check storage is full or not.
         * Need to stop capture action if full, but do NOT create warning window right now.
         */
        if(UI_Validate_Storage(STORAGE_CHECK_FULL, &g_uiFreePicNum) == FALSE)
        {
            /* Stop capture action */
            Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_CAPTURE_STOP,0);

        }

        /* Redraw all window OSD */
        //UxCtrl_SetDirty(pCtrl, TRUE);
    }
    else
    {   /* Normal cases */

        /* Set to preview mode */
        #if 0   //TODO: Need to wait ALGMSG_PREVIEWSTABLE, so let ALGMSG_PREVIEWSTABLE do this job
        UIFlowWndPhoto_SetToPreview();
        #endif

        /* Resume key after normal capture completed */
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
        Ux_FlushEvent();

        /* Update window info */
        UIFlowWndPhoto_UpdateWndInfo();
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnCaptureEnd(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    debug_err(("UIFlowWndPhoto: OnCaptureEnd\r\n"));

    if(Get_ContShotIndex() != CONT_SHOT_OFF)
    {
        if(g_bDoingContShot)
        {
            /* Set to preview mode */
            UIFlowWndPhoto_SetToPreview();

            /* Resume key after cont shot completed */
            KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);

            /* Update window info */
            UIFlowWndPhoto_UpdateWndInfo();

            g_bDoingContShot = FALSE;
        }
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnCapFstOK(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT16 uhFilesysDirNum, uhFilesysFileNum;

    debug_err(("UIFlowWndPhoto: OnCapFstOK\r\n"));

    FilesysGetDCFNextID(&uhFilesysDirNum, &uhFilesysFileNum);
    Set_FilesysDirId((UINT32)uhFilesysDirNum);
    Set_FilesysFileId((UINT32)uhFilesysFileNum);
    debug_ind(("UIFlowWndPhoto: NextDirNum = %d, NextFileNum = %d\r\n", Get_FilesysDirId(), Get_FilesysFileId()));

    /* Save DirNumber & FileNumber */
    //Save_MenuInfo();   //Let it be saved when poweroff

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnSmartScene(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    AlgMsgInfo *pAlgMsgInfo = Get_AlgMsgInfo();
    UINT32 uiPrevRunningScene = Get_RunningSceneIndex();
    UINT32 uiCurrRunningScene = uiPrevRunningScene;

    debug_ind(("UIFlowWndPhoto: OnSmartScene result = 0x%x\r\n", pAlgMsgInfo->SmartSceneRst));

    /* Check IQ SmartScene detection return value and update running scene index for UI icon change */
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_SMARTSCENECHECK,1,pAlgMsgInfo->SmartSceneRst);
    uiCurrRunningScene = Get_RunningSceneIndex();

    /* Update scene mode status item data and related configs (flash/ev/sharpness) item data by ref updated running scene index */
    if(uiCurrRunningScene != uiPrevRunningScene)
    {
        debug_err(("UIFlowWndPhoto: Smart renew running scene index to %ld\r\n", uiCurrRunningScene));

        UxState_SetData(&UIFlowWndPhoto_StatusICN_SceneCtrl,STATE_CURITEM,uiCurrRunningScene);
        #if (_FLASHLIGHT_ != _FLASHLIGHT_NONE_)
        UxState_SetData(&UIFlowWndPhoto_StatusICN_FlashCtrl,STATE_CURITEM,Get_FlashIndex());   //FlipDV has no flashlight
        #endif
        UxState_SetData(&UIFlowWndPhoto_StatusICN_EVCtrl,STATE_CURITEM,Get_EVIndex());

        if((uiCurrRunningScene != SCENE_SMART) && (uiCurrRunningScene != SCENE_AUTO))
        {
            UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_SceneCtrl,TRUE);
        }
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnOZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    AlgMsgInfo *pAlgMsgInfo = Get_AlgMsgInfo();
    //Rsvd
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnDZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    AlgMsgInfo *pAlgMsgInfo = Get_AlgMsgInfo();

    /* Update digital zoom ratio OSD string */
    UxStatic_SetData(&UIFlowWndPhoto_StaticTXT_DZoomCtrl,STATIC_VALUE,Txt_Pointer(Get_DZoomRatioString(pAlgMsgInfo)));

    if(pAlgMsgInfo->DzoomIndex > UI_DZOOM_IDX_MIN)
        UxCtrl_SetShow(&UIFlowWndPhoto_StaticTXT_DZoomCtrl,TRUE);
    else
        UxCtrl_SetShow(&UIFlowWndPhoto_StaticTXT_DZoomCtrl,FALSE);

    /* Hide FD frame when dzoom moving */
    UxCtrl_SetShow(&UIFlowWndPhoto_PNL_FDFrameCtrl,FALSE);

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnFdEnd(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    debug_ind(("UIFlowWndPhoto: OnFdEnd\r\n"));

    if((Get_FDIndex() != FD_OFF) && (!g_bStartCapture) && (!g_bQviewTimerStart))
    {
        /* Enable FD frame show */
        UxCtrl_SetShow(&UIFlowWndPhoto_PNL_FDFrameCtrl,TRUE);

        /* Redraw all window OSD */
        UxCtrl_SetDirty(pCtrl, TRUE);
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndPhoto_OnSdEnd(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    debug_err(("UIFlowWndPhoto: OnSdEnd\r\n"));

    if(!g_bSelfTimerStart)
    {
        /* Suspend all keys before sending capture command */
        KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_NULL);
        Ux_FlushEvent();

        /* Clear the whole OSD screen */
        UxCtrl_SetAllChildShow(pCtrl,FALSE);

        /* Start to send capture command */
        g_bStartCapture = TRUE;
        Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_CAPTURE,0);
    }

    return NVTEVT_CONSUME;
}

INT32 UIFlowWndPhoto_OnOSDReflash(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UxState_SetData(&UIFlowWndPhoto_StatusICN_LedLightCtrl,STATE_CURITEM,KeyScan_GetLedLightSta());	
    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_LedLightCtrl,TRUE);
    return NVTEVT_CONSUME;
}

//----------------------UIFlowWndPhoto_StaticICN_DSCModeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticICN_DSCMode)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_CaptureModeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_CaptureMode)
EVENT_END

//----------------------UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticTXT_SelftimerCnt)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_ISOCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_ISO)
EVENT_END

//----------------------UIFlowWndPhoto_StaticTXT_FreePicCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticTXT_FreePic)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_EVCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_EV)
EVENT_END

//----------------------UIFlowWndPhoto_StaticTXT_SizeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticTXT_Size)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_WBCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_WB)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_QualityCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Quality)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_ColorCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Color)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_FDCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_FD)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_SceneCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Scene)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_MacroCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Macro)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_StorageCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Storage)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_LedLightCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_LedLight)
EVENT_END

//----------------------UIFlowWndPhoto_StaticTXT_DZoomCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticTXT_DZoom)
EVENT_END

//----------------------UIFlowWndPhoto_StatusICN_BatteryCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StatusICN_Battery)
EVENT_END

//---------------------UIFlowWndPhoto_PNL_FDFrameCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndPhoto_PNL_FDFrame)
CTRL_LIST_END

//----------------------UIFlowWndPhoto_StaticICN_AntiShakeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPhoto_StaticICN_AntiShake)
EVENT_END
//----------------------UIFlowWndPhoto_PNL_FDFrameCtrl Event---------------------------
INT32 UIFlowWndPhoto_PNL_FDFrame_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPhoto_PNL_FDFrame)
EVENT_ITEM(NVTEVT_REDRAW,UIFlowWndPhoto_PNL_FDFrame_OnRedraw)
EVENT_END

INT32 UIFlowWndPhoto_PNL_FDFrame_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    AlgMsgInfo *pInfo = Get_AlgMsgInfo();
    UIScreen ScreenObj = *paramArray;
    FACE *pFace;
    UINT32 i;

    GxGfx_SetShapeColor(_OSD_INDEX_GREEN, _OSD_INDEX_GREEN, 0);

    for(i=0; i<pInfo->FaceDetectNum; i++)
    {
        pFace = &(pInfo->FaceDetectRect[i]);
        debug_err(("FDFrame[%02d] (%03d/%03d/%03d/%03d)\r\n", i, pFace->stx, pFace->sty, pFace->width, pFace->height));

        #if 1
        /* Rectangle frame style */
        GxGfx_FrameRect(((DC**)ScreenObj)[GxGfx_OSD], pFace->stx,
                                                      pFace->sty,
                                                      pFace->stx+pFace->width,
                                                      pFace->sty+pFace->height);
        #else
        /* Frame angle style */
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pFace->stx,
                                                 pFace->sty,
                                                 pFace->stx+FD_OSDFRAME_LEN,
                                                 pFace->sty);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pFace->stx,
                                                 pFace->sty,
                                                 pFace->stx,
                                                 pFace->sty+FD_OSDFRAME_LEN);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pFace->stx+pFace->width-FD_OSDFRAME_LEN,
                                                 pFace->sty,
                                                 pFace->stx+pFace->width,
                                                 pFace->sty);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pFace->stx+pFace->width,
                                                 pFace->sty,
                                                 pFace->stx+pFace->width,
                                                 pFace->sty+FD_OSDFRAME_LEN);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pFace->stx,
                                                 pFace->sty+pFace->height,
                                                 pFace->stx+FD_OSDFRAME_LEN,
                                                 pFace->sty+pFace->height);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pFace->stx,
                                                 pFace->sty+pFace->height-FD_OSDFRAME_LEN,
                                                 pFace->stx,
                                                 pFace->sty+pFace->height);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pFace->stx+pFace->width-FD_OSDFRAME_LEN,
                                                 pFace->sty+pFace->height,
                                                 pFace->stx+pFace->width,
                                                 pFace->sty+pFace->height);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pFace->stx+pFace->width,
                                                 pFace->sty+pFace->height-FD_OSDFRAME_LEN,
                                                 pFace->stx+pFace->width,
                                                 pFace->sty+pFace->height);
        #endif
    }

    return NVTEVT_CONSUME;
}

//-----------------------------------------------------------------------------
// UIFlowWndPhoto User Functions
//-----------------------------------------------------------------------------
static void UIFlowWndPhoto_InitCfgSetting(void)
{
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_CAPTUREMODE,1,Get_CaptureModeIndex());
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_FLASH,1,Get_FlashIndex());
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_QUALITY,1,Get_QualityIndex());
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_ISO,1,Get_ISOIndex());
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_EV,1,Get_EVIndex());
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_WB,1,Get_WBIndex());
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_COLOR,1,Get_ColorIndex());
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_METERING,1,Get_MeteringIndex());
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_SHARPNESS,1,Get_SharpnessIndex());
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_SATURATION,1,Get_SaturationIndex());
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_FD,1,Get_FDIndex());
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_ANTISHAKING,1,Get_AntiShakingIndex());
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_QUICKREVIEW,1,Get_QuickReviewIndex());
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_DATEIMPRINT,1,Get_DateImprintIndex());
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_SCENEMODE,1,Get_SceneModeIndex());
    /* Preview resolution setting must be set after other IQ settings */
    Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_SIZE,1,Get_SizeIndex());
}

static void UIFlowWndPhoto_InitWndParam(void)
{
   AlgMsgInfo *pAlgMsgInfo = Get_AlgMsgInfo();

	Photo_DZoom_GotoStep(UI_DZOOM_IDX_MIN);    
	pAlgMsgInfo->DzoomIndex = UI_DZOOM_IDX_MIN;
    /* Init window variables */
    g_bZoomInPressed = FALSE;
    g_bZoomOutPressed = FALSE;
    g_uiSelfTimerCnt = 0;
    g_bSelfTimerStart = FALSE;
    g_bQviewTimerStart = FALSE;
    g_bStartCapture = FALSE;
    g_bDoingContShot = FALSE;
    g_bContShotCfgSetOn = FALSE;
    g_bSceneModeCfgSetOther = FALSE;

    /* Init window key mask variables & set key press/release/continue mask */
    g_uiMaskKeyPress = PHOTO_KEY_PRESS_MASK;
    g_uiMaskKeyRelease = PHOTO_KEY_RELEASE_MASK;
    g_uiMaskKeyContinue = PHOTO_KEY_CONTINUE_MASK;
    Ux_FlushEvent();
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, g_uiMaskKeyRelease);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, g_uiMaskKeyContinue);
}

static void UIFlowWndPhoto_UpdateWndInfo(void)
{
    AlgMsgInfo *pAlgMsgInfo = Get_AlgMsgInfo();
    UINT32 uiMsg = 0;
    UINT32 uiValue = 0;
    BOOL bShow;
    if (GPIOMap_DetStrgCard() == FALSE)
    {
	    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_LedLightCtrl,FALSE);
		
	    /* Always show/hidden when updating */
	    UxCtrl_SetShow(&UIFlowWndPhoto_StaticICN_DSCModeCtrl,FALSE);
	    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_StorageCtrl,FALSE);
	    #if (_FLASHLIGHT_ != _FLASHLIGHT_NONE_)
	    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_FlashCtrl,FALSE);
	    #endif
	    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_CaptureModeCtrl,FALSE);
	    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_EVCtrl,FALSE);
	    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_WBCtrl,FALSE);
	    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_ISOCtrl,FALSE);
	    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_ColorCtrl,FALSE);
	    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_QualityCtrl,FALSE);
	    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_FDCtrl,FALSE);
	    UxCtrl_SetShow(&UIFlowWndPhoto_StaticICN_AntiShakeCtrl,FALSE);
	    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_MacroCtrl,FALSE);
	    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_BatteryCtrl,FALSE);
	    UxCtrl_SetShow(&UIFlowWndPhoto_StaticTXT_SizeCtrl,FALSE);
	    UxCtrl_SetShow(&UIFlowWndPhoto_StaticTXT_FreePicCtrl,FALSE);
	    UxCtrl_SetShow(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl,FALSE);
	    UxCtrl_SetShow(&UIFlowWndPhoto_PNL_FDFrameCtrl,FALSE);    
        g_uiChildWndMode = PHOTO_CHILD_WND_WRNMSG;
        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,FLOWWRNMSG_ISSUE_NO_CARD,FLOWWRNMSG_TIMER_KEEP);    
    }
    else
    	{
    /* Validate storage */
    if(UI_Validate_Storage(STORAGE_CHECK_ERROR, NULL) == FALSE)
    {
        #if ((_PSTOREDEVICE_ == _PSTOREDEVICE_SPIFLASH_) && (_RAM_DISK_ == DISABLE))
        uiMsg = (GetCardStatus() == CARD_REMOVED)? FLOWWRNMSG_ISSUE_NO_CARD : FLOWWRNMSG_ISSUE_CARD_ERR;
        #else
        uiMsg = (GetCardStatus() == CARD_REMOVED)? FLOWWRNMSG_ISSUE_MEM_ERR : FLOWWRNMSG_ISSUE_CARD_ERR;
        #endif
        g_uiChildWndMode = PHOTO_CHILD_WND_WRNMSG;
        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,uiMsg,FLOWWRNMSG_TIMER_2SEC);
        //return;
    }
    if(UI_Validate_Storage(STORAGE_CHECK_LOCKED, NULL) == FALSE)
    {
        g_uiChildWndMode = PHOTO_CHILD_WND_WRNMSG;
        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,FLOWWRNMSG_ISSUE_CARD_LOCKED,FLOWWRNMSG_TIMER_KEEP);
        //return;
    }
    if(UI_Validate_Storage(STORAGE_CHECK_FULL, &g_uiFreePicNum) == FALSE)
    {
        uiMsg = (GetCardStatus() == CARD_REMOVED)? FLOWWRNMSG_ISSUE_NO_CARD : FLOWWRNMSG_ISSUE_CARD_FULL;
        g_uiChildWndMode = PHOTO_CHILD_WND_WRNMSG;
        Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,uiMsg,FLOWWRNMSG_TIMER_2SEC);
        //return;
    }

    /* Update status item data */
    uiValue = (GetCardStatus() == CARD_REMOVED)? UIFlowWndPhoto_StatusICN_Storage_ICON_INTERNAL_FLASH : UIFlowWndPhoto_StatusICN_Storage_ICON_SD_CARD;
    UxState_SetData(&UIFlowWndPhoto_StatusICN_StorageCtrl,STATE_CURITEM,uiValue);
    #if (_FLASHLIGHT_ != _FLASHLIGHT_NONE_)
    UxState_SetData(&UIFlowWndPhoto_StatusICN_FlashCtrl,STATE_CURITEM,Get_FlashIndex());
    #endif
    UxState_SetData(&UIFlowWndPhoto_StatusICN_CaptureModeCtrl,STATE_CURITEM,Get_CaptureModeIndex());
    UxState_SetData(&UIFlowWndPhoto_StatusICN_SceneCtrl,STATE_CURITEM,Get_RunningSceneIndex());
    UxState_SetData(&UIFlowWndPhoto_StatusICN_EVCtrl,STATE_CURITEM,Get_EVIndex());
    UxState_SetData(&UIFlowWndPhoto_StatusICN_WBCtrl,STATE_CURITEM,Get_WBIndex());
    UxState_SetData(&UIFlowWndPhoto_StatusICN_ISOCtrl,STATE_CURITEM,Get_ISOIndex());
    UxState_SetData(&UIFlowWndPhoto_StatusICN_ColorCtrl,STATE_CURITEM,Get_ColorIndex());
    UxState_SetData(&UIFlowWndPhoto_StatusICN_QualityCtrl,STATE_CURITEM,Get_QualityIndex());
    UxState_SetData(&UIFlowWndPhoto_StatusICN_FDCtrl,STATE_CURITEM,Get_FDIndex());
    //UxState_SetData(&UIFlowWndPhoto_StaticICN_AntiShakeCtrl,STATE_CURITEM,Get_AntiShakingIndex());
    UxState_SetData(&UIFlowWndPhoto_StatusICN_MacroCtrl,STATE_CURITEM,Get_MacroIndex());
    UxState_SetData(&UIFlowWndPhoto_StatusICN_BatteryCtrl,STATE_CURITEM,GetBatteryLevel());
    UxStatic_SetData(&UIFlowWndPhoto_StaticTXT_SizeCtrl,STATIC_VALUE,Txt_Pointer(Get_SizeString(Get_SizeIndex())));
    UxStatic_SetData(&UIFlowWndPhoto_StaticTXT_DZoomCtrl,STATIC_VALUE,Txt_Pointer(Get_DZoomRatioString(pAlgMsgInfo)));
    UxStatic_SetData(&UIFlowWndPhoto_StaticTXT_FreePicCtrl,STATIC_VALUE,Txt_Pointer(Get_FreePicNumString(g_uiFreePicNum)));

    UxState_SetData(&UIFlowWndPhoto_StatusICN_LedLightCtrl,STATE_CURITEM,KeyScan_GetLedLightSta());	
    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_LedLightCtrl,FALSE);
	
    /* Always show/hidden when updating */
    UxCtrl_SetShow(&UIFlowWndPhoto_StaticICN_DSCModeCtrl,TRUE);
    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_StorageCtrl,TRUE);
    #if (_FLASHLIGHT_ != _FLASHLIGHT_NONE_)
    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_FlashCtrl,TRUE);
    #endif
    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_CaptureModeCtrl,TRUE);
    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_EVCtrl,TRUE);
    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_WBCtrl,TRUE);
    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_ISOCtrl,TRUE);
    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_ColorCtrl,TRUE);
    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_QualityCtrl,TRUE);
    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_FDCtrl,TRUE);
    if(Get_AntiShakingIndex() == ANTISHAKING_ON)
    UxCtrl_SetShow(&UIFlowWndPhoto_StaticICN_AntiShakeCtrl,FALSE);
    else		
    UxCtrl_SetShow(&UIFlowWndPhoto_StaticICN_AntiShakeCtrl,FALSE);
    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_MacroCtrl,TRUE);
    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_BatteryCtrl,FALSE);
    UxCtrl_SetShow(&UIFlowWndPhoto_StaticTXT_SizeCtrl,TRUE);
    UxCtrl_SetShow(&UIFlowWndPhoto_StaticTXT_FreePicCtrl,TRUE);
    UxCtrl_SetShow(&UIFlowWndPhoto_StaticTXT_SelftimerCntCtrl,FALSE);
    UxCtrl_SetShow(&UIFlowWndPhoto_PNL_FDFrameCtrl,FALSE);

    /* Conditional show/hidden when updating */
    bShow = (pAlgMsgInfo->DzoomIndex > UI_DZOOM_IDX_MIN)? TRUE : FALSE;
    UxCtrl_SetShow(&UIFlowWndPhoto_StaticTXT_DZoomCtrl,bShow);

    bShow = ((Get_RunningSceneIndex() != SCENE_SMART) && (Get_RunningSceneIndex() != SCENE_AUTO))? TRUE : FALSE;
    UxCtrl_SetShow(&UIFlowWndPhoto_StatusICN_SceneCtrl,bShow);

    /* Special treatment when config capture mode */
    UIFlowWndPhoto_SetCaptureModeSpecial(Get_CaptureModeIndex());

    /* Special treatment when config scene mode */
    UIFlowWndPhoto_SetSceneModeSpecial(Get_SceneModeIndex());

    /* Update FD/SD function process (lock/unlock) */
    UIFlowWndPhoto_SetFdSdProc(Get_FDIndex());
    	}
}

static void UIFlowWndPhoto_SetToQuickView(AlgMsgInfo *pAlgInfo)
{
    VIDEO_BUF_ADDR      FB_addr;
    VIDEO_BUF_ATTR      FB_attr;
    VOSD_WINDOW_ATTR    FB_win;
    UINT32 i;

    FB_addr.uiBufSel        = IDE_VIDEO_ADDR_SEL_BUFFER0;

    FB_attr.Buf_W           = pAlgInfo->Thumbnail_Hsize;
    FB_attr.Buf_H           = pAlgInfo->Thumbnail_Vsize;
    FB_attr.Buf_Lineoffset  = pAlgInfo->Thumbnail_Hsize >> 2;
    FB_attr.Buf_L2R         = IDE_BUFFER_READ_L2R;
    FB_attr.Buf_T2B         = IDE_BUFFER_READ_T2B;
    FB_attr.Buf_BJmode      = IDE_VIDEO_BJMODE_BUFFER_REPEAT;

    FB_attr.Buf_Opt         = IDE_VIDEO_BUFFER_OPT_0;
    FB_attr.Buf_Num         = IDE_VIDEO_BUFFER_NUM_1;

    FB_win.Source_W         = pAlgInfo->Thumbnail_Hsize;
    FB_win.Source_H         = pAlgInfo->Thumbnail_Vsize;
    FB_win.Des_W            = g_LCDSize.uiWinWidth;
    FB_win.Des_H            = g_LCDSize.uiWinHeight;
    FB_win.Win_Format       = COLOR_YCBCR422;
    FB_win.Win_X            = 0;
    FB_win.Win_Y            = 0;
    FB_win.High_Addr        = 0;

    ide_set_video_buf_attr(IDE_VIDEOID_1, &FB_attr);
    ide_set_video_win_attr(IDE_VIDEOID_1, &FB_win);

    for(i=0; i<pAlgInfo->Jpeg_Num; i++)
    {
        switch(i)
        {
            case 0:
                FB_addr.B0_Y    = pAlgInfo->Thumbnail0_Y_Addr;
                FB_addr.B0_CB   = pAlgInfo->Thumbnail0_Cb_Addr;
                FB_addr.B0_CR   = pAlgInfo->Thumbnail0_Cr_Addr;
                break;

            case 1:
                FB_addr.B0_Y    = pAlgInfo->Thumbnail1_Y_Addr;
                FB_addr.B0_CB   = pAlgInfo->Thumbnail1_Cb_Addr;
                FB_addr.B0_CR   = pAlgInfo->Thumbnail1_Cr_Addr;
                break;

            case 2:
                FB_addr.B0_Y    = pAlgInfo->Thumbnail2_Y_Addr;
                FB_addr.B0_CB   = pAlgInfo->Thumbnail2_Cb_Addr;
                FB_addr.B0_CR   = pAlgInfo->Thumbnail2_Cr_Addr;
                break;

            default:
                debug_err(("UIFlowWndPhoto_SetToQuickView: Invalid image number!!\r\n"));
                return;
        }

        ide_set_video_buf_addr(IDE_VIDEOID_1, &FB_addr);
        ide_enable_video(IDE_VIDEOID_1);
        ide_set_load();
    }
}

static void UIFlowWndPhoto_SetToPreview(void)
{
    #if 0   //New IQ flow does not need it here!!
    IPL_OBJ IplObj;

    IplObj.uiCmd = IPL_CMD_CHG_MODE;
    IplObj.Mode = IPL_MODE_PREVIEW;
    IPL_SetCmd(&IplObj);
    #endif

    PhotoDisplay_SetMode(DISPLAY_MODE_PREVIEW, TRUE);

    ide_enable_video(IDE_VIDEOID_1);
}

static void UIFlowWndPhoto_SetFdSdProc(UINT32 uiFDIndex)
{
    /* Set FD frame rate */
    Photo_SetFdRate(FD_FRAME_RATE);

    /* Lock/Unlock FD & SD */
    switch(uiFDIndex)
    {
        case FD_ON:
            if(Photo_IsFDLock())
            {
                Photo_LockFD(UNLOCK);
            }
            Photo_LockSD(LOCK);
            break;

        case FD_SMILE:
            if(Photo_IsFDLock())
            {
                Photo_LockFD(UNLOCK);
            }
            if(Photo_IsSDLock())
            {
                Photo_LockSD(UNLOCK);
            }
            break;

        case FD_OFF:
        default:
            Photo_LockFD(LOCK);
            Photo_LockSD(LOCK);
            break;
    }
}

static void UIFlowWndPhoto_ForceLockFdSd(UINT32 uiFDIndex)
{
    /* FD & SD should be forced locked in some cases */
    switch(uiFDIndex)
    {
        case FD_ON:
            Photo_LockFD(LOCK);
            break;

        case FD_SMILE:
            Photo_LockFD(LOCK);
            Photo_LockSD(LOCK);
            break;

        case FD_OFF:
        default:
            break;
    }
}

static void UIFlowWndPhoto_SetCaptureModeSpecial(UINT32 uiCaptureModeIndex)
{
#if 0
    switch(uiCaptureModeIndex)
    {
        case CAPTURE_MODE_SINGLE:
        case CAPTURE_MODE_SELFTIMER_2S:
        case CAPTURE_MODE_SELFTIMER_5S:
        case CAPTURE_MODE_SELFTIMER_10S:
            if(g_bContShotCfgSetOn)
            {
                /* Resume flash setting key */
                if(PHOTO_KEY_PRESS_MASK & PHOTO_FLASH_KEY)
                {
                    g_uiMaskKeyPress |= PHOTO_FLASH_KEY;
                    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
                }

                g_bContShotCfgSetOn = FALSE;
            }
            break;

        case CAPTURE_MODE_CONTSHOT3:
            if(!g_bContShotCfgSetOn)
            {
                /* Force flash setting to flash off */
                Ux_SendEvent(&UIPhotoObjCtrl,NVTEVT_EXE_FLASH,1,FLASH_OFF);
                UxState_SetData(&UIFlowWndPhoto_StatusICN_FlashCtrl,STATE_CURITEM,Get_FlashIndex());

                /* Mask flash setting key */
                g_uiMaskKeyPress &= ~(PHOTO_FLASH_KEY);
                KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);

                g_bContShotCfgSetOn = TRUE;
            }
            break;

        default:
            break;
    }
#endif
}

static void UIFlowWndPhoto_SetSceneModeSpecial(UINT32 uiSceneIndex)
{
#if 0
    switch(uiSceneIndex)
    {
        case SCENE_AUTO:
            if(g_bSceneModeCfgSetOther)
            {
                /* Resume flash setting key */
                if(PHOTO_KEY_PRESS_MASK & PHOTO_FLASH_KEY)
                {
                    g_uiMaskKeyPress |= PHOTO_FLASH_KEY;
                    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);
                }

                g_bSceneModeCfgSetOther = FALSE;
            }
            break;

        case SCENE_SMART:
        case SCENE_LANDSCAPE:
        case SCENE_BACKLIGHT:
        case SCENE_NIGHTSCENE:
        case SCENE_PORTRAIT:
        case SCENE_SPORTS:
            if(!g_bSceneModeCfgSetOther)
            {
                /* Mask flash setting key */
                g_uiMaskKeyPress &= ~(PHOTO_FLASH_KEY);
                KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, g_uiMaskKeyPress);

                g_bSceneModeCfgSetOther = TRUE;
            }
            break;

        default:
            break;
    }
#endif
}

