//This source code is generated by UI Designer Studio.
#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "UIGraphics.h"
#include "NVTToolCommand.h"
#include "UIFlowWndCommonRes.c"
#include "UIFlowWndCommon.h"
#include "KeyScanTsk.h"
#include "PhotoTsk.h"
#include "FileSysTsk.h"
//#include "UIMenuWndPhotoStill.h"
#include "UISystemObj.h"
#include "PrimaryTsk.h"
#define INTER_FRAME     1

//---------------------UIFlowWndCommon Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndCommon)
CTRL_LIST_ITEM(UIFlowWndCommon_TabHistogram)
CTRL_LIST_END

//----------------------UIFlowWndCommon Event---------------------------
INT32 UIFlowWndCommon_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndCommon_OnClose(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndCommon)
EVENT_ITEM(NVTEVT_OPEN_WINDOW,UIFlowWndCommon_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW,UIFlowWndCommon_OnClose)
EVENT_END

INT32 UIFlowWndCommon_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    /* Set key press/release/continue mask */
    Ux_FlushEvent();
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_DEFAULT);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, FLGKEY_KEY_REL_MASK_DEFAULT);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, FLGKEY_KEY_CONT_MASK_DEFAULT);

    Ux_DefaultEvent(pCtrl,NVTEVT_OPEN_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndCommon_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    /* Reset key press/release/continue mask to default */
    Ux_FlushEvent();
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_PRESS, FLGKEY_KEY_MASK_DEFAULT);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_RELEASE, FLGKEY_KEY_REL_MASK_DEFAULT);
    KeyScan_SetKeyMask(KEYSCAN_KEYMODE_CONTINUE, FLGKEY_KEY_CONT_MASK_DEFAULT);

    Ux_DefaultEvent(pCtrl,NVTEVT_CLOSE_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
//----------------------UIFlowWndCommon_TabHistogram Event---------------------------
INT32 UIFlowWndCommon_TabHistogram_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndCommon_TabHistogram)
EVENT_ITEM(NVTEVT_REDRAW,UIFlowWndCommon_TabHistogram_OnRedraw)
EVENT_END

INT32 UIFlowWndCommon_TabHistogram_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_DefaultEvent(pCtrl,NVTEVT_REDRAW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}

// HistogramData value would between 0~100
void UIFlowWndCommon_QuantizeHistoData(UINT32 *HistogramData, UINT32 uiTotal)
{
    UINT32 Max_Y_Hist =0;
    UINT32 i;

    //Get the max-value of histogram for normalization.
    for(i=0; i<uiTotal; i++)
    {
        if(HistogramData[i] > Max_Y_Hist)
            Max_Y_Hist = HistogramData[i] ;
    }
    for(i=0; i<uiTotal; i++)
    {
        HistogramData[i] = HistogramData[i]*100 / Max_Y_Hist;
    }
}
void UIFlowWndCommon_GetHistogram(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    DC** pDCList = (DC**)paramArray[0];
    SIZE_2D HistogramFrame = {128,50};
    UINT32 HistogramData[128];
    UINT32 i,uiTotalLine = 0;

    if(Primary_GetCurrentMode()==PRIMARY_MODE_PLAYBACK)
    {
        PB_ReadHistogram(HistogramData);   //Playback.
        uiTotalLine = 64;
    }
    else
    {
        Sen_GetAEHistResult(HistogramData); //Preview.
        uiTotalLine = 64 ;
    }

    GxGfx_SetShapeColor(CLRID_IDX_WHITE, CLRID_IDX_TRANSPART, 0);
    GxGfx_FillRect(pDCList[GxGfx_OSD],0,0,HistogramFrame.w,HistogramFrame.h);

    // Quantize Histogram data
    UIFlowWndCommon_QuantizeHistoData(HistogramData, uiTotalLine);

    GxGfx_FrameRect(pDCList[0],0,0, HistogramFrame.w , HistogramFrame.h);
    debug_ind(("   HistogramFrame.w %d HistogramFrame.h  %d  \r\n" ,HistogramFrame.w,HistogramFrame.h));

    HistogramFrame.w-= 2*INTER_FRAME;
    HistogramFrame.h-= 2*INTER_FRAME;

    //draw Histogram line
    GxGfx_SetShapeColor(CLRID_IDX_GREEN, CLRID_IDX_BLUE, 0);
    for(i=0; i<HistogramFrame.w; i++)
    {
        INT32   x1,x2,y1,y2;
        x1 = INTER_FRAME + i;
        x2 = INTER_FRAME + i;
        y1 = INTER_FRAME+(100 - HistogramData[i*uiTotalLine/HistogramFrame.w])*(HistogramFrame.h) /100;
        y2 = HistogramFrame.h+ INTER_FRAME;
        //debug_err(("[%d]%d %d %d %d \n\r",i,x1,x2,y1,y2));
        GxGfx_Line(pDCList[0],INTER_FRAME + i,
                              INTER_FRAME+(100 - HistogramData[i*uiTotalLine/HistogramFrame.w])*(HistogramFrame.h) /100  ,
                              INTER_FRAME +i,
                              HistogramFrame.h+ INTER_FRAME);
    }

#if 0
    for(i=0; i<64; i=i+8)
    {
        debug_msg("%d %d %d %d %d %d %d %d\n\r",
        HistogramData[i],
        HistogramData[i+1],
        HistogramData[i+2],
        HistogramData[i+3],
        HistogramData[i+4],
        HistogramData[i+5],
        HistogramData[i+6],
        HistogramData[i+7]);
    }
#endif
}

